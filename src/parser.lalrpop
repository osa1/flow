use std::str::FromStr;

use ast::*;
use lexer::Token;

#[LALR] grammar;

////////////////////////////////////////////////////////////////////////////////
// Lexer interface
////////////////////////////////////////////////////////////////////////////////

extern {
    enum Token {
        "+"      => Token::Plus,
        "-"      => Token::Minus,
        "*"      => Token::Star,
        "/"      => Token::Slash,
        "%"      => Token::Percent,
        "^"      => Token::Exp,
        "#"      => Token::Sh,
        "=="     => Token::Equal,
        "~="     => Token::NotEqual,
        "<="     => Token::LEq,
        ">="     => Token::GEq,
        "<"      => Token::LT,
        ">"      => Token::GT,
        "="      => Token::Assign,
        "("      => Token::RParen,
        ")"      => Token::LParen,
        "{"      => Token::LBrace,
        "}"      => Token::RBrace,
        "["      => Token::LBracket,
        "]"      => Token::RBracket,
        "::"     => Token::DColon,
        ";"      => Token::Semic,
        ":"      => Token::Colon,
        ","      => Token::Comma,
        "."      => Token::Dot,
        ".."     => Token::DDot,
        "..."    => Token::Ellipsis,
        "<<"     => Token::DLT,
        ">>"     => Token::DGT,
        "&"      => Token::Ampersand,
        "|"      => Token::Pipe,
        "//"     => Token::DSlash,
        "~"      => Token::Tilde,

        "and"    => Token::And,
        "break"  => Token::Break,
        "do"     => Token::Do,
        "else"   => Token::Else,
        "elseif" => Token::ElseIf,
        "end"    => Token::End,
        "false"  => Token::False,
        "for"    => Token::For,
        "function" => Token::Function,
        "goto"   => Token::Goto,
        "if"     => Token::If,
        "in"     => Token::In,
        "local"  => Token::Local,
        "nil"    => Token::Nil,
        "not"    => Token::Not,
        "or"     => Token::Or,
        "repeat" => Token::Repeat,
        "return" => Token::Return,
        "then"   => Token::Then,
        "true"   => Token::True,
        "until"  => Token::Until,
        "while"  => Token::While,

        Num      => Token::Num(<String>),
        SLit     => Token::SLit(<Vec<u8>>),
        Ident    => Token::Ident(<String>),
    }
}

////////////////////////////////////////////////////////////////////////////////
// Utilities
////////////////////////////////////////////////////////////////////////////////

// Zero or more things separated by a comma.
Comma<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T?> =>
        match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        }
};

// One or more things separated by a comma.
Comma1<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

////////////////////////////////////////////////////////////////////////////////
// Statements
////////////////////////////////////////////////////////////////////////////////

pub StmtList : Vec<Box<Stmt>> = {
    <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.reverse();
        stmts
    },
};

// Because of the ambiguity (Lua 5.3.1 manual chapter 3.3.1) in e.g.
//
//   local x = f(a)(b)
//
// Which can be parsed as one statement or two statements, we need a special
// production for list of statements, which doesn't let statements start with
// "(", when the previous statement is an assignment.
//
// Note also that this returns statement in reversed order! Reverse before use!
RevStmtList : Vec<Box<Stmt>> = {
    <lhss:VarList1> "=" <es:Explist1> <stmts:RevStmtList1> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Assign {
            lhss: lhss,
            rhss: es,
            is_local: false,
        }));
        stmts
    },

    "local" <lhss:Identlist1> "=" <es:Explist1> <stmts:RevStmtList1> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Assign {
            lhss: lhss.into_iter().map(|v| Var::Var(v)).collect(),
            rhss: es,
            is_local: true,
        }));
        stmts
    },

    <fcall:FunCall> <stmts:RevStmtList1> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::FunCall(fcall)));
        stmts
    },

    <stmts:RevStmtList1> =>
        stmts
};

// Every statement except function call.
RevStmtList1 : Vec<Box<Stmt>> = {
    "local" <lhss:Identlist1> <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Assign {
            lhss: lhss.into_iter().map(|v| Var::Var(v)).collect(),
            rhss: vec![],
            is_local: true,
        }));
        stmts
    },

    ";" <stmts:RevStmtList> =>
        stmts,

    "::" <l:Ident> "::" <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Label(l)));
        stmts
    },

    "break" <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Break));
        stmts
    },

    "do" <b:Block> "end" <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Do(b)));
        stmts
    },

    "while" <e:Exp1> "do" <b:Block> "end" <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::While(e, b)));
        stmts
    },

    "repeat" <b:Block> "until" <e:Exp1> "end" <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::Repeat(b, e)));
        stmts
    },

    "if" <e1:Exp1> "then" <b1:Block>
            <conds:ElseIfBlock*>
            <else_block:("else" <Block>)?>
            "end"
            <stmts:RevStmtList> => {
        let mut stmts = stmts;
        let mut conds = conds;
        conds.insert(0, (e1, b1));
        stmts.push(Box::new(Stmt::If { conds: conds, else_: else_block }));
        stmts
    },

    "for" <v:Ident> "=" <e1:Exp> "," <e2:Exp> <e3:("," <Exp>)?> "do" <b:Block> "end"
            <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::ForRange {
            var: v,
            start: e1,
            end: e2,
            step: e3,
            body: b,
        }));
        stmts
    },

    "for" <v:Identlist1> "in" <es:Explist1> "do" <b:Block> "end" <stmts:RevStmtList> => {
        let mut stmts = stmts;
        stmts.push(Box::new(Stmt::ForIn {
            vars: v,
            exps: es,
            body: b,
        }));
        stmts
    },

    "function" <n1:Ident> <ns:("." <Ident>)*> <mname:(":" <Ident>)?> <fundef:FunDef>
            <stmts:RevStmtList> => {
        let mut stmts = stmts;
        let mut ns = ns;

        let lhs = {
            match ns.pop() {
                None => Var::Var(n1),
                Some(last_field) => {
                    Var::Select(
                        ns.into_iter().fold(Box::new(Exp::Var(Var::Var(n1))), |e, f| {
                            Box::new(Exp::Var(Var::Select(e, Box::new(Exp::Var(Var::Var(f))))))
                        }),
                        Box::new(Exp::Var(Var::Var(last_field))))
                }
            }
        };

        let rhs = Box::new(Exp::FunDef {
            args: fundef.0,
            vararg: fundef.1,
            body: fundef.2,
        });

        stmts.push(Box::new(Stmt::Assign {
            lhss: vec![lhs],
            rhss: vec![rhs],
            is_local: false,
        }));

        stmts
    },

    "local" "function" <n:Ident> <fundef:FunDef> <stmts:RevStmtList> => {
        let mut stmts = stmts;
        let lhs = Var::Var(n);
        let rhs = Box::new(Exp::FunDef {
            args: fundef.0,
            vararg: fundef.1,
            body: fundef.2,
        });

        stmts
    },
};

ElseIfBlock : (Box<Exp>, Block) = {
    "elseif" <e:Exp> "then" <b:Block> =>
        (e, b)
};

pub Block : Block = {
    <stmts:StmtList> "return" <exps:Explist> =>
        Block {
            stmts: stmts,
            mb_ret: Some(exps),
        },
};

Explist    = Comma<Exp1>;
Explist1   = Comma1<Exp1>;
Identlist  = Comma<Ident>;
Identlist1 = Comma1<Ident>;
VarList1   = Comma1<Var>;

////////////////////////////////////////////////////////////////////////////////
// Expressions
////////////////////////////////////////////////////////////////////////////////

pub Exp : Box<Exp> = Exp1;

// or
Exp1 : Box<Exp> = {
    <e1:Exp1> "or" <e2:Exp2> =>
        Box::new(Exp::Binop(e1, Binop::Or, e2)),

    <e:Exp2> =>
        e
};

// and
Exp2 : Box<Exp> = {
    <e1:Exp2> "and" <e2:Exp3> =>
        Box::new(Exp::Binop(e1, Binop::And, e2)),

    <e:Exp3> =>
        e
};

// <     >     <=    >=    ~=    ==
Exp3 : Box<Exp> = {
    <e1:Exp3> <op:Binop3> <e2:Exp4> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp4> =>
        e
};

Binop3 : Binop = {
    "<"  => Binop::LT,
    ">"  => Binop::GT,
    "<=" => Binop::GTE,
    ">=" => Binop::LTE,
    "~=" => Binop::NEQ,
    "==" => Binop::EQ,
};

// |
Exp4 : Box<Exp> = {
    <e1:Exp4> "|" <e2:Exp5> =>
        Box::new(Exp::Binop(e1, Binop::BOr, e2)),

    <e:Exp5> =>
        e
};

// ~
Exp5 : Box<Exp> = {
    <e1:Exp5> "~" <e2:Exp6> =>
        Box::new(Exp::Binop(e1, Binop::BXor, e2)),

    <e:Exp6> =>
        e
};

// &
Exp6 : Box<Exp> = {
    <e1:Exp6> "&" <e2:Exp7> =>
        Box::new(Exp::Binop(e1, Binop::And, e2)),

    <e:Exp7> =>
        e
};

// <<    >>
Exp7 : Box<Exp> = {
    <e1:Exp7> <op:Binop7> <e2:Exp8> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp8> =>
        e
};

Binop7 : Binop = {
    "<<" => Binop::ShiftL,
    ">>" => Binop::ShiftR,
};

// ..
Exp8 : Box<Exp> = {
    // Right associative
    <e1:Exp9> ".." <e2:Exp8> =>
        Box::new(Exp::Binop(e1, Binop::Concat, e2)),

    <e:Exp9> =>
        e,
};

// +     -
Exp9 : Box<Exp> = {
    <e1:Exp9> <op:Binop9> <e2:Exp10> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp10> =>
        e
};

Binop9 : Binop = {
    "+" => Binop::Add,
    "-" => Binop::Sub,
};

// '*'    '/'     '//'    '%'
Exp10 : Box<Exp> = {
    <e1:Exp10> <op:Binop10> <e2:Exp11> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp11> =>
        e
};

Binop10 : Binop = {
    "*"  => Binop::Mul,
    "/"  => Binop::Div,
    "//" => Binop::IDiv,
    "%"  => Binop::Mod,
};

// unary operators ('not'   '#'     '-'     '~')
Exp11 : Box<Exp> = {
    <op:Unop> <e:Exp11> =>
        Box::new(Exp::Unop(op, e)),

    <e:Exp12> =>
        e
};

Unop : Unop = {
    "not" => Unop::Not,
    "#"   => Unop::Len,
    "-"   => Unop::Neg,
    "~"   => Unop::Complement,
};

Exp12 : Box<Exp> = {
    // Right associative
    <e1:Exp13> "^" <e2:Exp12> =>
        Box::new(Exp::Binop(e1, Binop::Exp, e2)),

    <e:Exp13> =>
        e,
};

Exp13 : Box<Exp> = {
    "nil" =>
        Box::new(Exp::Nil),

    "true" =>
        Box::new(Exp::Bool(true)),

    "false" =>
        Box::new(Exp::Bool(false)),

    <n:Num> =>
        Box::new(Exp::Number(n)),

    <s:SLit> =>
        Box::new(Exp::String(s)),

    "..." =>
        Box::new(Exp::Vararg),

    "function" <fundef:FunDef> =>
        Box::new(Exp::FunDef {
            args: fundef.0,
            vararg: fundef.1,
            body: fundef.2,
        }),

    <e:PrefixExp> =>
        e,
};

// TODO: Should I make this right-recursive instead?
PrefixExp : Box<Exp> = {
    <v:Var> =>
        Box::new(Exp::Var(v)),

    <fc:FunCall> =>
        Box::new(Exp::FunCall(fc)),

    "(" <e:Exp1> ")" =>
        e,
};

////////////////////////////////////////////////////////////////////////////////
// Re-used parts
////////////////////////////////////////////////////////////////////////////////

FunDef : (Vec<Id>, bool, Block) = {
    "(" <args:Identlist> <mb_vararg:"..."?> ")" <b:Block> "end" =>
        (args, mb_vararg.is_some(), b)
};

FunArgs : Vec<Box<Exp>> = {
    "(" <es:Explist> ")" =>
        es,
};

FunCall : FunCall = {
    <e1:PrefixExp> <args:FunArgs> =>
        FunCall::FunCall(e1, args),

    <e1:PrefixExp> ":" <mname:Ident> <args:FunArgs> =>
        FunCall::MethodCall(e1, mname, args),
};

Var : Var = {
    <i:Ident> =>
        Var::Var(i),

    <e1:PrefixExp> "[" <e2:Exp1> "]" =>
        Var::Select(e1, e2),

    <e1:PrefixExp> "." <i:Ident> =>
        Var::Select(e1, Box::new(Exp::String(i.into_bytes()))),
};
