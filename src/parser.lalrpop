use std::str::FromStr;

use lexer::Token;
use ast::*;

#[LALR] grammar;

extern {
    enum Token {
        "+"      => Token::Plus,
        "-"      => Token::Minus,
        "*"      => Token::Star,
        "/"      => Token::Slash,
        "%"      => Token::Percent,
        "^"      => Token::Exp,
        "#"      => Token::Sh,
        "=="     => Token::Equal,
        "~="     => Token::NotEqual,
        "<="     => Token::LEq,
        ">="     => Token::GEq,
        "<"      => Token::LT,
        ">"      => Token::GT,
        "="      => Token::Assign,
        "("      => Token::RParen,
        ")"      => Token::LParen,
        "{"      => Token::LBrace,
        "}"      => Token::RBrace,
        "["      => Token::LBracket,
        "]"      => Token::RBracket,
        "::"     => Token::DColon,
        ";"      => Token::Semic,
        ":"      => Token::Colon,
        ","      => Token::Comma,
        "."      => Token::Dot,
        ".."     => Token::DDot,
        "..."    => Token::Ellipsis,
        "<<"     => Token::DLT,
        ">>"     => Token::DGT,
        "&"      => Token::Ampersand,
        "|"      => Token::Pipe,
        "//"     => Token::DSlash,
        "~"      => Token::Tilde,

        "and"    => Token::And,
        "break"  => Token::Break,
        "do"     => Token::Do,
        "else"   => Token::Else,
        "elseif" => Token::ElseIf,
        "end"    => Token::End,
        "false"  => Token::False,
        "for"    => Token::For,
        "function" => Token::Function,
        "goto"   => Token::Goto,
        "if"     => Token::If,
        "in"     => Token::In,
        "local"  => Token::Local,
        "nil"    => Token::Nil,
        "not"    => Token::Not,
        "or"     => Token::Or,
        "repeat" => Token::Repeat,
        "return" => Token::Return,
        "then"   => Token::Then,
        "true"   => Token::True,
        "until"  => Token::Until,
        "while"  => Token::While,

        Num      => Token::Num(<String>),
        SLit     => Token::SLit(<Vec<u8>>),
        Ident    => Token::Ident(<String>),
    }
}

pub Stmt : Box<Stmt> = {
    "break" =>
        Box::new(Stmt::Break),

    "::" <l:Ident> "::" =>
        Box::new(Stmt::Label(l)),

    "do" <b:Block> "end" =>
        Box::new(Stmt::Do(b)),
};

pub Block : Block = {
    <stmts:Stmt*> "return" <exps:Explist> =>
        Block {
            stmts: stmts,
            mb_ret: Some(exps),
        }
};

pub Explist = Comma<Exp1>;
pub Varlist = Comma<Ident>;

Comma<T> : Vec<T> = {
    <v:(<T> ",")*> <e:T?> =>
        match e {
            None => v,
            Some(e) => {
                let mut v = v;
                v.push(e);
                v
            }
        }
};

pub Exp : Box<Exp> = Exp1;

// or
Exp1 : Box<Exp> = {
    <e1:Exp1> "or" <e2:Exp2> =>
        Box::new(Exp::Binop(e1, Binop::Or, e2)),

    <e:Exp2> =>
        e
};

// and
Exp2 : Box<Exp> = {
    <e1:Exp2> "and" <e2:Exp3> =>
        Box::new(Exp::Binop(e1, Binop::And, e2)),

    <e:Exp3> =>
        e
};

// <     >     <=    >=    ~=    ==
Exp3 : Box<Exp> = {
    <e1:Exp3> <op:Binop3> <e2:Exp4> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp4> =>
        e
};

Binop3 : Binop = {
    "<"  => Binop::LT,
    ">"  => Binop::GT,
    "<=" => Binop::GTE,
    ">=" => Binop::LTE,
    "~=" => Binop::NEQ,
    "==" => Binop::EQ,
};

// |
Exp4 : Box<Exp> = {
    <e1:Exp4> "|" <e2:Exp5> =>
        Box::new(Exp::Binop(e1, Binop::BOr, e2)),

    <e:Exp5> =>
        e
};

// ~
Exp5 : Box<Exp> = {
    <e1:Exp5> "~" <e2:Exp6> =>
        Box::new(Exp::Binop(e1, Binop::BXor, e2)),

    <e:Exp6> =>
        e
};

// &
Exp6 : Box<Exp> = {
    <e1:Exp6> "&" <e2:Exp7> =>
        Box::new(Exp::Binop(e1, Binop::And, e2)),

    <e:Exp7> =>
        e
};

// <<    >>
Exp7 : Box<Exp> = {
    <e1:Exp7> <op:Binop7> <e2:Exp8> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp8> =>
        e
};

Binop7 : Binop = {
    "<<" => Binop::ShiftL,
    ">>" => Binop::ShiftR,
};

// ..
Exp8 : Box<Exp> = {
    // Right associative
    <e1:Exp9> ".." <e2:Exp8> =>
        Box::new(Exp::Binop(e1, Binop::Concat, e2)),

    <e:Exp9> =>
        e,
};

// +     -
Exp9 : Box<Exp> = {
    <e1:Exp9> <op:Binop9> <e2:Exp10> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp10> =>
        e
};

Binop9 : Binop = {
    "+" => Binop::Add,
    "-" => Binop::Sub,
};

// '*'    '/'     '//'    '%'
Exp10 : Box<Exp> = {
    <e1:Exp10> <op:Binop10> <e2:Exp11> =>
        Box::new(Exp::Binop(e1, op, e2)),

    <e:Exp11> =>
        e
};

Binop10 : Binop = {
    "*"  => Binop::Mul,
    "/"  => Binop::Div,
    "//" => Binop::IDiv,
    "%"  => Binop::Mod,
};

// unary operators ('not'   '#'     '-'     '~')
Exp11 : Box<Exp> = {
    <op:Unop> <e:Exp11> =>
        Box::new(Exp::Unop(op, e)),

    <e:Exp12> =>
        e
};

Unop : Unop = {
    "not" => Unop::Not,
    "#"   => Unop::Len,
    "-"   => Unop::Neg,
    "~"   => Unop::Complement,
};

Exp12 : Box<Exp> = {
    // Right associative
    <e1:Exp13> "^" <e2:Exp12> =>
        Box::new(Exp::Binop(e1, Binop::Exp, e2)),

    <e:Exp13> =>
        e,
};

Exp13 : Box<Exp> = {
    "nil" =>
        Box::new(Exp::Nil),

    "true" =>
        Box::new(Exp::Bool(true)),

    "false" =>
        Box::new(Exp::Bool(false)),

    <n:Num> =>
        Box::new(Exp::Number(n)),

    <s:SLit> =>
        Box::new(Exp::String(s)),

    "..." =>
        Box::new(Exp::Vararg),

    "function" "(" <args:Varlist> <mb_vararg:"..."?> ")" <b:Block> "end" =>
        Box::new(Exp::FunDef {
            args: args,
            vararg: mb_vararg.is_some(),
            body: b,
        }),

    <e:PrefixExp> <args:FunArgs> =>
        Box::new(Exp::FunCall(FunCall::FunCall {
            fun: e,
            args: args
        })),
};

PrefixExp : Box<Exp> = {
    <v:Ident> =>
        Box::new(Exp::Var(v)),

    "(" <e:Exp1> ")" =>
        e,

    <e:FunCall> =>
        Box::new(Exp::FunCall(e)),
};

FunCall : FunCall = {
    <f:PrefixExp> <args:FunArgs> =>
        FunCall::FunCall {
            fun: f,
            args: args,
        },

    <obj:PrefixExp> ":" <mname:Ident> <args:FunArgs> =>
        FunCall::MethodCall {
            obj: obj,
            mname: mname,
            args: args,
        },
};

FunArgs : Vec<Box<Exp>> = {
    "(" <es:Explist> ")" =>
        es,
};
